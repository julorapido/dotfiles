import { parse } from 'astrojs-compiler-sync';
import { Position, Range } from 'graphql-language-service';
import { babelParser } from './babel';
function parseAstro(source) {
    var _a, _b;
    const { ast, diagnostics } = parse(source, undefined);
    if (diagnostics.some(d => d.severity === 1)) {
        return {
            type: 'error',
            errors: diagnostics.map(d => JSON.stringify(d)),
        };
    }
    for (const node of ast.children) {
        if (node.type === 'frontmatter') {
            try {
                return {
                    type: 'ok',
                    scriptOffset: ((_b = (_a = node.position) === null || _a === void 0 ? void 0 : _a.start.line) !== null && _b !== void 0 ? _b : 1) - 1,
                    scriptAst: [babelParser(node.value, ['typescript'])],
                };
            }
            catch (error) {
                return {
                    type: 'error',
                    errors: [String(error)],
                };
            }
        }
    }
    return { type: 'error', errors: ['Could not find frontmatter block'] };
}
export const astroParser = (text, uri, logger) => {
    const parseAstroResult = parseAstro(text);
    if (parseAstroResult.type === 'error') {
        logger.error(`Could not parse the astro file at ${uri} to extract the graphql tags:`);
        for (const error of parseAstroResult.errors) {
            logger.error(String(error));
        }
        return null;
    }
    const rangeMapper = range => {
        return new Range(new Position(range.start.line + parseAstroResult.scriptOffset, range.start.character), new Position(range.end.line + parseAstroResult.scriptOffset, range.end.character));
    };
    return { asts: parseAstroResult.scriptAst, rangeMapper };
};
//# sourceMappingURL=astro.js.map